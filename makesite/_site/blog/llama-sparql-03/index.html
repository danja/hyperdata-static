<!DOCTYPE html>
<html>

<head>
    <title>llama_index SPARQL Notes 03 - Another Interim Blog</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
</head>

<body id="llama-sparql-03">
    <script id="replace_with_navbar" src="/share/nav.js"></script>
    <br />
    <br />
    <br />
    <em>Interim blog setup, rough notes being dumped here at the moment - I'll tidy once I get to a milestone. And sorry
        about the layout, that'll probably take even longer to get around to... #TODO</em>
    <br />
    <br />
    <main>
        <article>
<h1><a href="/blog/llama-sparql-03/">llama_index SPARQL Notes 03</a></h1>
<p class="meta">Published on 2023-08-29 by <b>@danja</b></p>
<h3>Today</h3>
<p><em>I'm down to $0.23 OpenAI API credit, so until I next have $ need to look at things that don't need it. <code>sparql.py</code> doesn't in itself need the OpenAI API, but a SPARQLy version of Wey Gu's Notebook is my target functional E2E test.</em></p>
<blockquote>
<p>I still have NebulaGraph data generated from Wey's Notebook. I can use nebula-python to pull out data from there, RDFLib to build RDF, sparqlwrapper to push to store. The SPARQL needed will be essentially the same as for <code>sparql.py</code>. Also NebulaGraph &lt;=&gt; RDF utils would be nice to have (may already exist, but I'll pretend I didn't consider that, need to inform myself).</p>
</blockquote>
<p>Then -</p>
<ul>
<li>have a look around <em>3 Create VectorStoreIndex for RAG</em> in Notebook</li>
<li>put the INSERT &amp; SELECT queries inside sparql.py</li>
<li>...</li>
</ul>
<hr />
<p><strong>MOVE PATH FROM llama_index INSTALLED TO DEV TREE</strong></p>
<p><strong>sudo /usr/local/nebula/scripts/nebula.service start all</strong></p>
<p>Started with :</p>
<p><code>resp = client.execute_json('MATCH (v:entity) RETURN v')</code></p>
<p>After converting this to string there were character encoding errors. Should really be investigated properly, but for now I'll just go with some quick &amp; dirty sanitization (Valid RDF literals will probably need <em>something</em> anyhow).</p>
<p><code>json_str = resp.decode('utf-8')</code> appears to have fixed the encoding issues.</p>

</article>

    </main>

    <footer>
        <section>
            <p>&copy; 2023 Danny Ayers, CC Attribution/MIT License</p>
            <p>Made with <a href="https://github.com/sunainapai">makesite</a></p>
        </section>
    </footer>

</body>

</html>